<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		//var fNum;//桃数
		/**
		 * 
		 */
		//起码有5+5
		
			//第一只猴子能分
			/**
			 * 正推，实际就是设桃子数，看能够分5次，每一次都不能分出小数，不满足桃子数就再
			 * 如果设一开始桃为i,五次分桃如下，都要能   % 5 === 0
			 * (i - 1) 		b=(i - 1)*0.8	下一只猴子能对剩下的0.8选
			 * b-1 剩下的桃子-1仍能%5，同理取完0.2，剩下的   c=（b-1）*0.8
			 * (i - 1)*0.8-1 *0.8-1
			 * (i - 1)*0.8-1 *0.8-1 *0.8-1
			 * (i - 1)*0.8-1 *0.8-1 *0.8-1 *0.8-1
			 * 
			 * 逆推的话，需要逐层满足条件，假设最后一个猴子分到i，逐层for上去看是否满足条件
			 * i		tem   207
			 * 
			 
			 * b=(i/0.2+1)/0.8    b
			 * c=b /0.8+1
			 */
			//
		//var lastNum = 10;//起码有10个桃
		//var i = 1;//i为最后一个猴子拿到的桃数
		var tem ;
		var i = 1;
	
		for(var i = 1; ; i++){
			//这一层for可以不写，因为只要最小桃数
		
			//console.log("进入第一个for"+"i值"+i);
			tem =  (i * 5 + 1 )/0.8+1 ;
			//第四只猴子分时的总数，须满足是5的倍数
			//下面判断上四层猴子能否满足
			for (var j = 1; j <= 4; j++) {
				//注意无限循环不执行，比如这里写成j>=4则console.log出不来
				//console.log("进入第二个for"+"i值"+i);
				//逐层判断上4层满不满足条件:桃子为整数且为5倍数
				
				if((tem -1) % 5 === 0 && parseInt(tem) === tem){
					//满足，则tem再上一层
					/**
					 * j =1 第4层
					 * 2 3
					 * 3 2
					 * 4 1
					 */
					console.log("满足"+"tem值"+tem);
					var reasult = tem;
					tem = tem / 0.8 + 1
					if(j == 4){//已经是到第一个猴子这里了，说明i满足条件
						console.log("满足"+"j值"+j+"桃数"+reasult+"最后一个猴子拿到的桃数："+i)
						alert("满足的桃子数目为："+reasult);
						break;
					}
				}else{//某一层不满足
					//console.log("不满足"+"j值"+j);
					break;
					//跳出当前for，遍历下一个i，即最后一个猴子拿到的桃数
				}
			}
		}
			
	
	</script> 
</html>
