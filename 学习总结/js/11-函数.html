<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>函数</title>
	</head>
	
	<body>
		<h1>函数</h1>
		<pre>
			基本理解：
				函数就是把完成特定功能的一段代码封装起来。给该功能起一个名字
				函数是完成某一功能、可重复执行的代码段
				函数方便管理和维护 便于复用
				函数声明也叫函数定义
			函数声明：
				声明函数时，如果后定义的函数名与前面定义的函数名重复了，则后定义的会覆盖前定义的
				function 函数名(形式参数1, 形式参数2, ...){
				   //函数体  
				}
				定义形参（形式参数）的时候只需要参数名，而不要var来声明,添加var反而报错
				形参可作为函数内的局部变量使用
				
				根据需要决定是否添加return语句
				结束函数(只要碰到return语句，不管代码执行到了什么地方，也不管进入了多少层循环，那么方法都会立即执行，并返回)
			函数的赋值问题：
				function test(){
						    //alert("哥们,我是匿名函数内的代码");
						    return 2
						 }
				var f1 = test()//
				console.log(f1+typeof f1)//2 number,说明将test返回值赋给f1,f1是nuumber类型
				var f2 = function test2(){}
				console.log(f2+typeof f2)//function test2(){}function function,说明f2是将函数test2复制了一份，类型为函数
			函数调用：
				函数只有被调用才能被执行			
				函数调用语法：
					方法名(实际参数1，实际参数2);
				传递的实参，会被形参接受，然后就可以在函数内部使用了,形参相当于函数内部定义的局部变量
				
				在调用函数的时候，实参的个数可以形参的个数一致，也可以不一致，没有实参匹配的形参值为undefined
				arguments
					形参和实参匹配的时候总是按照顺序匹配，多余的形参放在arguments中
					arguments不需要手动创建，在调用函数的时候，会自动创建，并把传递过来的所有实参的值都保存在里面
					arguments相当于数组的一种对象
					可以用[]去访问arguments中每个元素
					内部存在两个特殊属性
					1、callee
					该属性指向拥有该argument对象的函数			
					2、caller
					该属性保存当前函数的调用
					console.log(arguments.callee.caller)
				
			变量的作用域：
				变量的作用域指的是，变量起作用的范围。也就是能访问到变量的有效范围
				变量分为：
					全局变量		在window上的变量，函数外声明的变量
					局部变量		不在window上的变量，函数内声明的变量和形参
					因此全局变量可跨标签起作用
					局部变量的作用域是函数的内部
					<span style="color: red;">全局变量声明会提前，但是赋值过程不会提前</span>
			重名问题：
				局部变量的作用域会覆盖全局变量的作用域，即值暂时取局部变量的值
				但是一到函数外，变量值又变为全局变量的值
				函数内一定要用全局变量的话用window.变量名也是可以的，这样不会被局部值覆盖
			块级作用域： js无块级作用域，例如if(){}，大括号内部定义的在大括号外仍有效。
			匿名函数：没名字的函数，
				不能单独定义，否则 无法调用，因此会报错。可以用以下两种情况调用
					想在别的地方调用匿名函数，则应该声明一个变量，并把匿名函数赋值给这个变量：
						var f = function(){
						    alert("哥们我是匿名函数内的代码");
						  }
						f();  //调用上面定义的匿名函数
						把这个变量名做为函数名来调用
						可以将匿名函数作为参数传递给其他函数
					定义完立即执行：因为只执行一次所以不必写函数名
						(function () {
							alert("匿名函数立即执行")
						})();
			js不支持函数重载：
				重载：方法名相同，参数列表不同
				但是js中两个函数的名字相同，那么后定义的函数会覆盖先定义的函数，而且实参和形参可以不匹配，故不存在重载的情况
				可以模拟重载：使用arguments
			函数的递归调用：
				自己调用自己
				一定要满足两个条件：要有结束条件；递归过程逐步靠近结束条件
				<script type="text/javascript">
					/**
					 * 10!
					 */
					var num = 10;
					function factorial(num){
						if(num==1){
							return 1;
						}
						return num*factorial(--num)
					}
					//alert(factorial(num));
				</script>
		</pre>
	</body>
</html>
